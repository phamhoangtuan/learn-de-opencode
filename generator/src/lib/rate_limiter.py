"""Token bucket rate limiter for transaction generation.

Implements a token bucket algorithm using time.monotonic() for
precise rate limiting of transaction generation.

Per spec.md FR-002: Configurable rate from 1 to 1000 tx/sec.
"""

import time
import threading


class RateLimiter:
    """Token bucket rate limiter.

    Controls the rate at which transactions are generated by
    maintaining a bucket of tokens that refills at a constant rate.

    Attributes:
        rate: Target rate in tokens per second.
    """

    def __init__(self, rate: int) -> None:
        """Initialize the rate limiter.

        Args:
            rate: Target rate in tokens per second. Must be >= 1.

        Raises:
            ValueError: If rate is less than 1.
        """
        if rate < 1:
            msg = f"Rate must be at least 1, got {rate}"
            raise ValueError(msg)

        self._rate = rate
        self._tokens = float(rate)  # Start with a full bucket
        self._max_tokens = float(rate)  # Max bucket capacity = 1 second worth
        self._last_refill = time.monotonic()
        self._lock = threading.Lock()

    @property
    def rate(self) -> int:
        """Current rate in tokens per second."""
        return self._rate

    def _refill(self) -> None:
        """Refill tokens based on elapsed time since last refill."""
        now = time.monotonic()
        elapsed = now - self._last_refill
        new_tokens = elapsed * self._rate
        self._tokens = min(self._max_tokens, self._tokens + new_tokens)
        self._last_refill = now

    def acquire(self) -> bool:
        """Try to acquire a single token without blocking.

        Returns:
            True if a token was acquired, False if bucket is empty.
        """
        with self._lock:
            self._refill()
            if self._tokens >= 1.0:
                self._tokens -= 1.0
                return True
            return False

    def wait(self) -> None:
        """Block until a token is available, then acquire it.

        Sleeps in small increments until a token refills.
        """
        while not self.acquire():
            # Sleep for the minimum time needed for one token
            sleep_time = 1.0 / self._rate
            time.sleep(sleep_time)

    def update_rate(self, new_rate: int) -> None:
        """Update the token generation rate.

        Args:
            new_rate: New rate in tokens per second. Must be >= 1.

        Raises:
            ValueError: If new_rate is less than 1.
        """
        if new_rate < 1:
            msg = f"Rate must be at least 1, got {new_rate}"
            raise ValueError(msg)

        with self._lock:
            self._refill()  # Settle current tokens before changing rate
            self._rate = new_rate
            self._max_tokens = float(new_rate)
            # Don't reset tokens â€” allow smooth transition
            self._tokens = min(self._tokens, self._max_tokens)
